// LICENSE : MIT
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var twttr = _interopRequireWildcard(require("twitter-text"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// DEBUG=TweetTruncator*
var debug = require("debug")("TweetTruncator");

var joinText = function joinText(array, separator) {
  var isNotEmpty = function isNotEmpty(string) {
    return string.length > 0;
  };

  return array.filter(isNotEmpty).join(separator);
};

var defaultOptions = {
  defaultPrefix: "",
  template: "%desc% \"%title%\" %url% %tags%",
  truncatedOrder: ["tags", "title", "quote", "desc", "url"],
  // text…
  elisionMark: "…"
};

var TweetTruncator = /*#__PURE__*/function () {
  function TweetTruncator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TweetTruncator);

    this.template = options.template || defaultOptions.template;
    this.defaultPrefix = options.defaultPrefix || defaultOptions.defaultPrefix;
    this.truncatedOrder = options.truncatedOrder || defaultOptions.truncatedOrder;
    this.elisionMark = options.elisionMark || defaultOptions.elisionMark;
    this.twitterTextOptions = options.twitterTextOptions || {};
  }

  _createClass(TweetTruncator, [{
    key: "getTweetLength",
    value: function getTweetLength(str) {
      return twttr.getTweetLength(str, this.twitterTextOptions);
    }
  }, {
    key: "joinContents",
    value: function joinContents(contents) {
      var template = this.template;
      var desc = contents.desc,
          quote = contents.quote,
          title = contents.title,
          url = contents.url,
          tags = contents.tags;
      var prefix = desc ? "" : this.defaultPrefix;
      return template ? this.extractTemplate(prefix, template, contents) : joinText([prefix, desc, quote, title, url].concat(_toConsumableArray(tags)), " ");
    }
  }, {
    key: "extractTemplate",
    value: function extractTemplate(prefix, template, contents) {
      contents.usage = {};
      var fixedTemplate = template.replace(/%(desc|quote|title|url|tags|br)%/g, function (match, name) {
        if (name === "br") {
          return "\n";
        }

        contents.usage[name] = true;
        return contents[name].length ? match : "";
      }).trim().replace(/^ +| +$/gm, "").replace(/ +/g, " ");
      return joinText([prefix].concat(_toConsumableArray(fixedTemplate.split(" "))).map(function (content) {
        return content.replace(/%(desc|quote|title|url|tags)%/g, function (match, name) {
          return name === "tags" ? contents.tags.join(" ") : contents[name];
        });
      }), " ");
    }
  }, {
    key: "truncateStatus",
    value: function truncateStatus(contents) {
      var overLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var over = overLength;

      var copiedContents = _objectSpread({}, contents);

      var elisionMark = this.elisionMark;
      var getTweetLength = this.getTweetLength.bind(this);
      var truncateContent = this.truncateContent.bind(this);
      var truncators = {
        tags: function tags(array) {
          var arr = array.slice();
          copiedContents.tags = arr.reverse().filter(function (tag) {
            if (over <= 0) {
              return true;
            }

            over -= tag.length;
          }).reverse();
          debug("tags: ".concat(arr.length, " -> ").concat(copiedContents.tags.length));

          if (copiedContents.tags.length || over <= 0) {
            return true;
          }
        },
        title: function title(string) {
          var str = truncateContent(string, over + elisionMark.length);
          debug("[TITLE] over: ".concat(over, "\n").concat(string, "\n                ->\n").concat(str.length ? str : "[DELETE]"));

          if (str) {
            copiedContents.title = str + elisionMark;
          } else {
            over -= getTweetLength(string) + 1;
            copiedContents.title = str;

            if (over > 0) {
              return false;
            }
          }

          return true;
        },
        quote: function quote(string) {
          var str = truncateContent(string.slice(1, -1), over + elisionMark.length);
          debug("[Quote] over: ".concat(over, "\n").concat(string, "\n                ->\n").concat(str.length ? str : "[DELETE]"));

          if (str) {
            copiedContents.quote = "".concat(str).concat(elisionMark);
          } else {
            over -= getTweetLength(string) + 1;
            copiedContents.quote = str;

            if (over > 0) {
              return false;
            }
          }

          return true;
        },
        desc: function desc(string) {
          var str = truncateContent(string, over + elisionMark.length) + elisionMark;
          copiedContents.desc = str;
          debug("[DESC] over: ".concat(over, "\n").concat(string, "\n                ->\n").concat(str.length ? str : "[DELETE]"));
          return true;
        },
        url: function url(string) {
          // no change
          return true;
        }
      };

      for (var i = 0; i < this.truncatedOrder.length - 1; i++) {
        if (over <= 0) {
          break;
        }

        var truncatorName = this.truncatedOrder[i];

        if (copiedContents.usage && !copiedContents.usage[truncatorName]) {
          copiedContents[truncatorName] = truncatorName === "tags" ? [] : "";
        }

        var content = copiedContents[truncatorName];
        var truncate = truncators[truncatorName];

        if (content.length && truncate(content)) {
          break;
        }
      }

      return this.joinContents(copiedContents);
    }
  }, {
    key: "truncateContent",
    value: function truncateContent(content, overLength) {
      // for surrogate pair
      var strArr = _toConsumableArray(content);

      var urls = twttr.extractUrlsWithIndices(content).reverse();
      var twLen = this.getTweetLength(content);
      var over = overLength;

      if (!urls.length || twLen <= over + 1) {
        return strArr.slice(0, -(over + 1)).join("");
      }

      for (var i = 0; i < urls.length; i++) {
        var indices = urls[i].indices;
        var start = indices[0];
        var end = indices[1];
        var len = strArr.length;

        if (over < len - end) {
          break;
        }

        strArr = strArr.slice(0, start - (len === end ? end : len));
        over -= twLen - this.getTweetLength(strArr.join(""));

        if (over < 0) {
          break;
        }

        twLen = this.getTweetLength(strArr.join(""));
      }

      if (over >= 0) {
        strArr = strArr.slice(0, -(over + 1));
      }

      return strArr.join("");
    }
  }]);

  return TweetTruncator;
}();

exports["default"] = TweetTruncator;
//# sourceMappingURL=tweet-truncator.js.map